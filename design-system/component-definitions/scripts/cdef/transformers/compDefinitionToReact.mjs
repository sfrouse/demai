


export default function compDefitionToReact(
    cdef,
    className
) {
    if (!cdef) return '';
    const xCDef = cdef['x-cdef'];
    if (!xCDef) return '';
    const tag = xCDef.tag || cdef.$id;
    // const name = xCDef.name || tag;

    // process variables...
    // const ignoreTypingError = '// @ts-ignore: Suppress ts(2322) error';
    const props = [];
    const attributes = [];
    const reactAttrs = [];
    let isRichText = false;
    let isSlotted = false;
    if (cdef.properties) {
        Object.entries(cdef.properties).map(entry => {
            const name = entry[0];
            const property = entry[1];
            if (['$schema', '$identifier'].indexOf(name) !== -1) return;
            const xCDef = property['x-cdef'];
            if (xCDef.hidden === true) return;
            if (xCDef.output?.webComponent?.slot === true) {
                isSlotted = true;
                return;
            }
            if (xCDef.input?.options) {
                props.push(`${name}: "${property.enum.join('" | "')}" | undefined,`);
            }else{
                const figmaTypeFunk = cdefTypeToTypeScriptType(xCDef.input.inputType);
                props.push(`${name}: ${figmaTypeFunk},`);
            }

            isRichText = xCDef.input.inputType === 'richText';
            if (isRichText) {
                attributes.push(`${name}={documentToHtmlString(props.${name})}`);
                reactAttrs.push(`${name}:documentToHtmlString(props.${name})`)
            }else{
                attributes.push(`${name}={props.${name}}`);
                reactAttrs.push(`${name}:props.${name}`);
            }
        });
    }

    // Get the current date in YYYY-MM-DD format
    return `/* eslint-disable */
// @ts-nocheck
/**
 * THIS FILE IS AUTOGENERATED. DO NOT EDIT THIS FILE DIRECTLY.
 * Any changes made here will be overwritten during the next build.
 * 
 * Generated on: ${new Date().toISOString().split('T')[0]}
 */
import React, { useEffect, useRef } from 'react';
import { createElement } from "@lit-labs/ssr-react";
${isRichText ? `import { documentToHtmlString } from "@contentful/rich-text-html-renderer";` : ''}

interface ${className}Props {
    ${props.join('\n\t')}
}

const ${className}: React.FC<${className}Props> = (props) => {
    /* return <${tag}
        ${attributes.join(`\n\t\t`)}>${
            isSlotted ? `\n\t\t\t{props.children}` : ''}
        </${tag}>;*/

    const attrs = {
        ${reactAttrs.join(',\n            ')}
    };

    const filteredProps = Object.entries(attrs).reduce((acc, [key, value]) => {
        if (value !== undefined) {
            acc[key] = value;
        }
        return acc;
    }, {});

    return createElement(
        "${tag}",
        {
            suppressHydrationWarning: true,
            ...filteredProps
        },${
        isSlotted ? `\n\t\t\tprops.children` : ''}
    );
};

export default ${className};

declare global {
    namespace JSX {
        interface IntrinsicElements {
            '${tag}': React.DetailedHTMLProps<
                React.HTMLAttributes<HTMLElement>,
                Partial<${className}Props>,
                HTMLElement
            >
        }
    }
}`;
}

function cdefTypeToTypeScriptType(cdefType) {
    switch( cdefType ) {
        case 'string' :
            return 'string';
        case 'boolean' :
            return 'boolean';
        case 'number' :
            return 'number';
        case 'richText' :
            return 'object';
        default:
            return 'string'
    }
}